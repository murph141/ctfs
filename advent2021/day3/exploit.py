#!/usr/bin/env python3

from Cryptodome.Cipher import AES  # pip3 install pycryptodomex
import socket
import struct
import time

DEBUG = False

HOST = 'santassecrets.advent2021.overthewire.org'
PORT = 1209

TWO_CHAR_UNICODE = 'Â²'
RANDOM_INPUT_CHAR = b'x'
RANDOM_KEY_CHAR = b'A'

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    return s

def send_request(sock, data):
    data = data + b'\n'
    sock.sendall(data)
    return sock.recv(1024)

def encrypt(sock):
    # We always use the old key and encrypt from 6 into 7
    return send_request(sock, b'encrypt 5 7 6')

def get_write_key(pad_size):
    inp = b''
    for i in range(pad_size):
        inp += TWO_CHAR_UNICODE.encode()

    for i in range(16 - pad_size):
        inp += RANDOM_KEY_CHAR

    return inp

def write_key(sock, pad_size):
    inp = get_write_key(pad_size)

    req = b'write_key 4 ' + inp + b' ascii'

    if DEBUG:
        print(f'Requesting: {req}, size: {len(req)}')

    return send_request(sock, req)

def write_data(sock):
    req = b'write_data 6 ' + RANDOM_INPUT_CHAR * 16 + b' ascii'
    return send_request(sock, req)

def read_data(sock, index):
    req = f'read_data {index}'.encode()
    return send_request(sock, req)

def exploit():

    sock = connect()

    # write initial data

    write_data(sock)

    # read the encrypted flags

    flag_one = read_data(sock, 0).strip()
    flag_two = read_data(sock, 1).strip()

    if DEBUG:
        print(f'Encrypted flag: {flag_one + flag_two}')

    # Start overwriting key

    enc_values = []
    for i in range(16):
        # Write the key (and overwrite existing key `i` bytes)

        write_key(sock, i)

        # Encrypt known plaintext

        encrypt(sock)

        # Read encrypted value and store

        enc = read_data(sock, 7)
        enc_values.append(enc)

        time.sleep(0.1)

    if DEBUG:
        print(f'Encrypted values: {enc_values}')

    found = bytearray(b'_' * 16)
    for i in range(16):
        index = 16 - i - 1
        pad_length = index
        write = get_write_key(pad_length)
        pad = write[16:]

        end_pad = b''
        for j in range(i):
            end_pad = struct.pack('<B', found[15-j]) + end_pad

        for j in range(256):
            guess = pad + struct.pack('<B', j) + end_pad

            encrypted = AES.new(key=guess, mode=AES.MODE_ECB).encrypt(RANDOM_INPUT_CHAR*16)

            if encrypted.hex() == enc_values[index].strip().decode():
                if DEBUG:
                    print(f'Match found: {struct.pack("<B", j)}')

                found[index] = j
                break

    key = bytes(found)

    if DEBUG:
        print(f'Found key: {key}')

    decryptor = AES.new(key=key, mode=AES.MODE_ECB)

    f_one = bytes.fromhex(flag_one.decode())
    f_two = bytes.fromhex(flag_two.decode())

    flag = (decryptor.decrypt(f_one) + decryptor.decrypt(f_two)).decode()

    print(f'Flag: {flag}')

    sock.close()

if __name__ == '__main__':
    exploit()
